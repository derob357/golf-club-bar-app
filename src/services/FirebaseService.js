import firestore from '@react-native-firebase/firestore';

/**
 * Firebase Firestore Database Structure
 * 
 * This file documents the complete database schema for the Golf Club Bar Management App
 */

// ============================================
// COLLECTIONS STRUCTURE
// ============================================

/**
 * Collection: users
 * Purpose: Store bartender and manager accounts
 * 
 * Document Structure:
 * {
 *   uid: string (auto-generated by Firebase Auth),
 *   email: string,
 *   role: 'bartender' | 'manager',
 *   name: string,
 *   phone: string,
 *   active: boolean,
 *   createdAt: Timestamp,
 *   updatedAt: Timestamp
 * }
 * 
 * Indexes:
 * - role (for filtering by user type)
 * - active (for filtering active users)
 */

/**
 * Collection: members
 * Purpose: Store golf club member information (up to 50,000)
 * 
 * Document Structure:
 * {
 *   memberId: string (4-digit number, e.g., "1234"),
 *   firstName: string,
 *   lastName: string,
 *   email: string,
 *   phone: string,
 *   address: string,
 *   membershipType: string,
 *   joinDate: Timestamp,
 *   active: boolean,
 *   totalPurchases: number,
 *   lastPurchaseDate: Timestamp,
 *   favoriteItems: array<string>,
 *   createdAt: Timestamp,
 *   updatedAt: Timestamp
 * }
 * 
 * Indexes:
 * - memberId (unique, for quick lookup)
 * - active (for filtering active members)
 * - lastName (for searching)
 */

/**
 * Collection: orders
 * Purpose: Store all drink purchase transactions
 * 
 * Document Structure:
 * {
 *   orderId: string (auto-generated),
 *   memberId: string (4-digit member ID),
 *   memberName: string,
 *   bartenderId: string (user uid),
 *   bartenderName: string,
 *   items: array<{
 *     itemId: string,
 *     name: string,
 *     category: 'cocktail' | 'beer' | 'wine' | 'spirits' | 'custom',
 *     brand: string,
 *     price: number,
 *     quantity: number,
 *     notes: string
 *   }>,
 *   subtotal: number,
 *   tax: number,
 *   total: number,
 *   eventName: string (optional, for event-based reporting),
 *   timestamp: Timestamp,
 *   paymentStatus: 'pending' | 'completed' | 'cancelled',
 *   notes: string
 * }
 * 
 * Indexes:
 * - memberId (for member purchase history)
 * - bartenderId (for bartender performance)
 * - timestamp (for time-based queries)
 * - eventName (for event reporting)
 * - Composite: timestamp + memberId
 * - Composite: eventName + timestamp
 */

/**
 * Collection: inventory
 * Purpose: Store available drinks and their information
 * 
 * Document Structure:
 * {
 *   itemId: string (auto-generated),
 *   name: string,
 *   category: 'cocktail' | 'beer' | 'wine' | 'spirits' | 'custom',
 *   brand: string (for beers and spirits),
 *   type: string (e.g., 'IPA', 'Lager', 'Whiskey'),
 *   price: number,
 *   description: string,
 *   ingredients: array<string> (for cocktails),
 *   inStock: boolean,
 *   popularity: number (order count for recommendations),
 *   imageUrl: string,
 *   createdAt: Timestamp,
 *   updatedAt: Timestamp
 * }
 * 
 * Indexes:
 * - category (for filtering)
 * - inStock (for availability)
 * - popularity (for recommendations)
 */

/**
 * Collection: settings
 * Purpose: Store app-wide settings
 * 
 * Document: app_settings
 * {
 *   taxRate: number,
 *   reportTimeframes: array<string>,
 *   notificationsEnabled: boolean,
 *   autoSyncInterval: number,
 *   defaultEventName: string
 * }
 * 
 * Document: user_preferences/{userId}
 * {
 *   defaultTimeframe: string,
 *   notificationsEnabled: boolean,
 *   theme: 'light' | 'dark'
 * }
 */

/**
 * Collection: events
 * Purpose: Store special events for event-based reporting
 * 
 * Document Structure:
 * {
 *   eventId: string,
 *   name: string,
 *   description: string,
 *   startDate: Timestamp,
 *   endDate: Timestamp,
 *   active: boolean,
 *   totalSales: number,
 *   orderCount: number
 * }
 */

// ============================================
// FIREBASE SERVICE FUNCTIONS
// ============================================

class FirebaseService {
  // User Management
  async createUser(userData) {
    try {
      const userRef = await firestore().collection('users').add({
        ...userData,
        createdAt: firestore.FieldValue.serverTimestamp(),
        updatedAt: firestore.FieldValue.serverTimestamp(),
      });
      return userRef.id;
    } catch (error) {
      console.error('Error creating user:', error);
      throw error;
    }
  }

  async getUserById(uid) {
    try {
      const userDoc = await firestore().collection('users').doc(uid).get();
      return userDoc.exists ? { id: userDoc.id, ...userDoc.data() } : null;
    } catch (error) {
      console.error('Error fetching user:', error);
      throw error;
    }
  }

  // Member Management
  async getMemberById(memberId) {
    try {
      // Validate input
      if (!memberId || typeof memberId !== 'string') {
        console.error('Invalid member ID:', memberId);
        return null;
      }
      
      // Sanitize: ensure exactly 4 digits
      const sanitizedId = memberId.trim();
      if (!/^\d{4}$/.test(sanitizedId)) {
        console.error('Member ID must be exactly 4 digits:', sanitizedId);
        return null;
      }
      
      const memberSnapshot = await firestore()
        .collection('members')
        .where('memberId', '==', sanitizedId)
        .limit(1)
        .get();

      if (!memberSnapshot || memberSnapshot.empty) {
        return null;
      }

      const doc = memberSnapshot.docs[0];
      if (!doc || !doc.exists) {
        return null;
      }
      
      const data = doc.data();
      if (!data || typeof data !== 'object') {
        console.error('Invalid member data structure');
        return null;
      }
      
      return { id: doc.id, ...data };
    } catch (error) {
      console.error('Error fetching member:', error);
      return null; // Return null instead of throwing to prevent crashes
    }
  }

  async getAllMembers(limit = 100) {
    try {
      const snapshot = await firestore()
        .collection('members')
        .where('active', '==', true)
        .limit(limit)
        .get();

      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
      console.error('Error fetching members:', error);
      throw error;
    }
  }

  async createMember(memberData) {
    try {
      const memberRef = await firestore().collection('members').add({
        ...memberData,
        totalPurchases: 0,
        favoriteItems: [],
        active: true,
        createdAt: firestore.FieldValue.serverTimestamp(),
        updatedAt: firestore.FieldValue.serverTimestamp(),
      });
      return memberRef.id;
    } catch (error) {
      console.error('Error creating member:', error);
      throw error;
    }
  }

  // Order Management
  async createOrder(orderData) {
    try {
      // Comprehensive input validation
      if (!orderData || typeof orderData !== 'object') {
        throw new Error('Invalid order data');
      }
      if (!orderData.memberId || typeof orderData.memberId !== 'string') {
        throw new Error('Valid member ID is required');
      }
      if (!orderData.memberName || typeof orderData.memberName !== 'string') {
        throw new Error('Member name is required');
      }
      if (!orderData.bartenderId || typeof orderData.bartenderId !== 'string') {
        throw new Error('Bartender ID is required');
      }
      if (!Array.isArray(orderData.items) || orderData.items.length === 0) {
        throw new Error('Order must contain at least one item');
      }
      if (typeof orderData.subtotal !== 'number' || orderData.subtotal < 0) {
        throw new Error('Valid subtotal is required');
      }
      if (typeof orderData.tax !== 'number' || orderData.tax < 0) {
        throw new Error('Valid tax amount is required');
      }
      if (typeof orderData.total !== 'number' || orderData.total <= 0) {
        throw new Error('Valid total is required');
      }

      // Validate all items
      for (const item of orderData.items) {
        if (!item || typeof item !== 'object') {
          throw new Error('Invalid item in order');
        }
        if (!item.name || typeof item.name !== 'string') {
          throw new Error('Item name is required');
        }
        if (typeof item.price !== 'number' || item.price < 0) {
          throw new Error('Valid item price is required');
        }
        if (typeof item.quantity !== 'number' || item.quantity <= 0) {
          throw new Error('Valid item quantity is required');
        }
      }

      // Sanitize order data
      const sanitizedOrder = {
        memberId: orderData.memberId.trim(),
        memberName: orderData.memberName.trim(),
        bartenderId: orderData.bartenderId.trim(),
        bartenderName: (orderData.bartenderName || '').trim(),
        items: orderData.items.map(item => ({
          itemId: item.itemId || '',
          name: item.name.trim(),
          category: item.category || 'custom',
          brand: (item.brand || '').trim(),
          price: Number(item.price),
          quantity: Number(item.quantity),
          notes: (item.notes || '').trim(),
        })),
        subtotal: Number(orderData.subtotal),
        tax: Number(orderData.tax),
        total: Number(orderData.total),
        eventName: (orderData.eventName || '').trim(),
        notes: (orderData.notes || '').trim(),
        timestamp: firestore.FieldValue.serverTimestamp(),
        paymentStatus: 'completed',
      };

      const orderRef = await firestore().collection('orders').add(sanitizedOrder);

      if (!orderRef || !orderRef.id) {
        throw new Error('Failed to create order');
      }

      // Update member's total purchases (with error recovery)
      try {
        const member = await this.getMemberById(sanitizedOrder.memberId);
        if (member && member.id) {
          await firestore().collection('members').doc(member.id).update({
            totalPurchases: firestore.FieldValue.increment(sanitizedOrder.total),
            lastPurchaseDate: firestore.FieldValue.serverTimestamp(),
            updatedAt: firestore.FieldValue.serverTimestamp(),
          });
        }
      } catch (memberUpdateError) {
        // Log but don't fail the order if member update fails
        console.error('Failed to update member statistics:', memberUpdateError);
      }

      return orderRef.id;
    } catch (error) {
      console.error('Error creating order:', error);
      throw error;
    }
  }

  async getOrdersByTimeframe(startDate, endDate) {
    try {
      // Validate dates
      if (!startDate || !(startDate instanceof Date) || isNaN(startDate.getTime())) {
        throw new Error('Valid start date is required');
      }
      if (!endDate || !(endDate instanceof Date) || isNaN(endDate.getTime())) {
        throw new Error('Valid end date is required');
      }
      if (startDate > endDate) {
        throw new Error('Start date must be before end date');
      }

      const snapshot = await firestore()
        .collection('orders')
        .where('timestamp', '>=', startDate)
        .where('timestamp', '<=', endDate)
        .orderBy('timestamp', 'desc')
        .get();

      if (!snapshot) {
        return [];
      }

      return snapshot.docs.map(doc => {
        if (!doc || !doc.exists) return null;
        const data = doc.data();
        return data ? { id: doc.id, ...data } : null;
      }).filter(order => order !== null);
    } catch (error) {
      console.error('Error fetching orders:', error);
      return []; // Return empty array instead of throwing
    }
  }

  async getOrdersByEvent(eventName) {
    try {
      const snapshot = await firestore()
        .collection('orders')
        .where('eventName', '==', eventName)
        .orderBy('timestamp', 'desc')
        .get();

      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
      console.error('Error fetching event orders:', error);
      throw error;
    }
  }

  async getOrdersByMember(memberId, limit = 50) {
    try {
      const snapshot = await firestore()
        .collection('orders')
        .where('memberId', '==', memberId)
        .orderBy('timestamp', 'desc')
        .limit(limit)
        .get();

      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
      console.error('Error fetching member orders:', error);
      throw error;
    }
  }

  // Inventory Management
  async getInventoryByCategory(category) {
    try {
      const snapshot = await firestore()
        .collection('inventory')
        .where('category', '==', category)
        .where('inStock', '==', true)
        .get();

      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
      console.error('Error fetching inventory:', error);
      throw error;
    }
  }

  async getAllInventory() {
    try {
      const snapshot = await firestore()
        .collection('inventory')
        .where('inStock', '==', true)
        .orderBy('popularity', 'desc')
        .get();

      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
      console.error('Error fetching all inventory:', error);
      throw error;
    }
  }

  async updateItemPopularity(itemId) {
    try {
      await firestore().collection('inventory').doc(itemId).update({
        popularity: firestore.FieldValue.increment(1),
      });
    } catch (error) {
      console.error('Error updating popularity:', error);
    }
  }

  // Settings Management
  async getAppSettings() {
    try {
      const doc = await firestore()
        .collection('settings')
        .doc('app_settings')
        .get();
      return doc.exists ? doc.data() : null;
    } catch (error) {
      console.error('Error fetching settings:', error);
      throw error;
    }
  }

  async getUserPreferences(userId) {
    try {
      const doc = await firestore()
        .collection('settings')
        .doc('user_preferences')
        .collection(userId)
        .doc('preferences')
        .get();
      return doc.exists ? doc.data() : null;
    } catch (error) {
      console.error('Error fetching user preferences:', error);
      throw error;
    }
  }
}

export default new FirebaseService();
